<title>Terser-online</title>

<script src="terser.4.8.0.browser.bundle.js"></script>
<script src="regpack/contextDescriptor_browser.js"></script>
<script src="regpack/stringHelper.js"></script>
<script src="regpack/packerData.js"></script>
<script src="regpack/shapeShifter.js"></script>
<script src="regpack/regPack.js"></script>
<script src="regpack/patternViewer.js"></script>
<script src="regpack/thermalViewer.js"></script>

<h2><a href="https://github.com/fabiosantoscode/terser">Terser</a>-online (ES6 minifier)</h2>
<label><input type=checkbox id=check onchange="options.hidden = !this.checked"> show terser options</label> 
<label><input type=checkbox id=extra checked> extra compression (js1k)</label> 
<label><input type=checkbox id=zopfli onchange="deflated.hidden = !this.checked; output.oninput()"> compress via zopfli</label> 
<br>
<br>
<main>
<textarea id=input placeholder=input></textarea>
<textarea id=options hidden>// options
{
  toplevel: true,
  compress: {
    passes: 5,
    unsafe: true,
    pure_getters: true
  },
}</textarea>
<section>
  <textarea id=output placeholder=output></textarea>
  <br style=clear:both>
  <span class=size id=outsize>Output size: 0b</span>
  <span class=ops>
    <button onclick="output.value=pack(output.value); output.oninput()">RegPack</button>
    <input size=2 id=paramOExcludedVars value="a b c" title="reassign variables except for these">
    <input size=1 id=paramFGain value="1">
    <input size=1 id=paramFLength value="0">
    <input size=1 id=paramFCopies value="0">
  </span>
</section>
<section id=deflated hidden>
  <textarea id=deflatedvis placeholder=deflated></textarea>
  <br style=clear:both>
  <span class=size id=deflatedsize>Deflated size: 0b</span>
  <span class=ops>
    <input id=zipFilename size=10 value=a.js onchange=output.oninput()>
    <button onclick=downloadzip()>Export to zip</button>
  </span>
</section>
</main>

<style>
h2 { margin: 0 0 5px; }
body { font-family: arial; }
main { display: flex; flex-direction: row; gap: 10px; }
main>* { flex: 1 1 0; }
textarea { width: 100%; }
.ops { float: right; }
input[size="1"] { width: 15px }
section>*:first-child { height: calc(100vh - 130px); }
.size, .ops { display: inline-block; margin: 10px 0 0; }
</style>

<script>
worker = null;
pending = new Map();
nexttag = 1;
function callworker(...args) {
  if (!worker) {
    worker = new Worker('compress.js');
    worker.onmessage = e => {
      const [tag, err, ret] = e.data;
      const callbacks = pending.get(tag);
      console.assert(callbacks, 'dropped message');
      pending.delete(tag);
      callbacks[err](ret);
    };
  }
  const tag = nexttag++;
  return new Promise((resolve, reject) => {
    worker.postMessage([tag, ...args]);
    pending.set(tag, [resolve, reject]);
  });
}

check.checked = zopfli.checked = 0;
input.value = output.value = deflatedvis.value = "";
onload = function(){
  input.oninput = options.oninput = extra.onchange = function(){
    try{eval("opt = " + options.value)} catch(e){ opt = {} }
    if(extra.checked){
      result = Terser.minify("onload = function(){" + input.value + "}", opt);
    }
    else {
      result = Terser.minify(input.value, opt);
    }
    
    if(result.error){
      output.value = "// error\n" + result.error;
      return;
    }
    else {
      if(extra.checked){
        output.value = result.code.length > 21 ? result.code.slice(0, -1).replace(/-- >/g, "-->").replace(/onload=function\(\){(var )?(.*)}/,"$2") : "";
      }
      else {
        output.value = byteLength > 1 ? result.code : "";
      }
    }

    output.oninput();
  }
  
  output.oninput = async function(){
    outsize.innerHTML = "Output size: " + packer.getByteLength(output.value) + "b";

    if (!zopfli.checked) return;

    const inflatedbuf = Uint8Array.from(
      encodeURIComponent(output.value)
        .replace(/%(..)/g, (_, m) => String.fromCharCode(parseInt(m, 16))),
      c => c.charCodeAt());

    // TODO need better throttling
    deflatedvis.disabled = zipFilename.disabled = true;
    console.time('compress');
    const deflatedbuf = await callworker('compress', inflatedbuf, 'deflate', { numiterations: 100 });
    console.timeEnd('compress');
    const zipped = await callworker('makeZip', zipFilename.value, inflatedbuf, deflatedbuf);
    deflatedvis.disabled = zipFilename.disabled = false;
    deflatedvis.value = [...zipped].map(v => v.toString(16).padStart(2, '0')).join(' ');
    deflatedsize.innerHTML = "Deflated size: " + deflatedbuf.length + "b";
  }

  downloadzip = function() {
    const digits = deflatedvis.value.matchAll(/[0-9a-f]{2}/gi);
    const buf = Uint8Array.from(digits, ([c]) => parseInt(c, 16));
    const blob = new Blob([buf.buffer], { type: 'application/zip' });
    const url = URL.createObjectURL(blob);

    const tempanchor = document.createElement('a');
    tempanchor.setAttribute('href', url);
    tempanchor.setAttribute('download', buf.length + '.zip');
    tempanchor.click();
    URL.revokeObject(url);
  };
}

pack = function(input){
  
  // Get rid of comments and empty lines
  input = input.replace(/([\r\n]|^)\s*\/\/.*|[\r\n]+\s*/g,'');
  var options = {
    withMath : false,
    hash2DContext : true,
    hashWebGLContext : true,
    hashAudioContext : true,
    contextVariableName : "c",
    contextType : 0,
    reassignVars : true,
    varsNotReassigned : document.getElementById("paramOExcludedVars").value,
    crushGainFactor : parseFloat(document.getElementById("paramFGain").value),
    crushLengthFactor : parseFloat(document.getElementById("paramFLength").value),
    crushCopiesFactor : parseFloat(document.getElementById("paramFCopies").value),
    crushTiebreakerFactor : 1,
    wrapInSetInterval : false,
    timeVariableName : "",
    useES6 : true
  };

  var originalLength = packer.getByteLength(input);
  var inputList = packer.runPacker(input, options);
  var methodCount = inputList.length;
  var patternViewer = new PatternViewer;
  var thermalViewer = new ThermalViewer;
    
  var bestMethod=0, bestStage=0, bestCompression=1e8;
  for (var i=0; i<methodCount; ++i) {
    var packerData = inputList[i];
    //console.log(packerData);
    for (var j=0; j<4; ++j) {
      var output = (j==0 ? packerData.contents : packerData.result[j-1][1]);
      var packedLength = packer.getByteLength(output);
      //console.log(packedLength);
      if (packedLength > 0 && packedLength < bestCompression) {
        bestCompression = packedLength;
        bestMethod = i;
        bestStage = j;
      } 
    }
  } 

  var bestOutput = inputList[bestMethod];
  outsize.innerHTML = "Output size: " + (bestCompression) + "b";
  //console.log(bestOutput.result[bestStage-1][1]);
  //console.log(bestOutput, bestStage-1);
  
  return bestOutput.result[bestStage-1][1];
}
</script>
